/// <summary>
/// This source file was auto-generated by a tool - Any changes may be overwritten!
/// From Unity assembly definition: UltimateReplay.dll
/// From source file: Assets/Ultimate Replay 3.0/Scripts/Runtime/Storage/Stream/ReplayStreamStorage.cs
/// </summary>
using System;
using System.Collections.Generic;
using System.IO;
using System.IO.Compression;
using System.Text;
using System.Threading;

namespace UltimateReplay.Storage
{
    public enum ReplayStreamType
    {
        /// <summary>
        /// The result system will use the default replay format when writing or reading the stream (Binary format by default).
        /// </summary>
        Default = 0,
        /// <summary>
        /// The replay system will use a high performance binary stream format for best performance and storage requirements.
        /// </summary>
        Binary = 1,
        /// <summary>
        /// The replay system will use a human readable json stream format for the replay. Useful for working with replay data in other applications when using a TextWriter for example.
        /// </summary>
        Json = 2,
#if !ULTIMATERPLAY_DISABLE_BSON
        /// <summary>
        /// The replay system with use bson file format.
        /// </summary>
        Bson,
#endif
    }

    public abstract partial class ReplayStreamStorage : ReplayStorage
    {
#endif
        // Protected
        protected bool useSegmentCompression = true;
        protected int snapshotsPerSegment = 30;
        protected Stream writeStream = null;
        protected Stream readStream = null;
        // Properties
        protected abstract ReplayStreamSource StreamSource
        {
            get;
        }

        public override bool CanRead
        {
            get
            {
                CheckDisposed();
                return StreamSource.CanRead;
            }
        }

        public override bool CanWrite
        {
            get
            {
                CheckDisposed();
                return StreamSource.CanWrite;
            }
        }

        public override float Duration
        {
            get
            {
                CheckDisposed();
                return header.duration;
            }
        }

        public override int MemorySize
        {
            get
            {
                CheckDisposed();
                return header.memorySize;
            }
        }

        public override int SnapshotSize
        {
            get
            {
                CheckDisposed();
                return header.snapshotCount;
            }
        }

        public override int IdentitySize
        {
            get
            {
                CheckDisposed();
                return header.identityByteSize;
            }
        }

        public bool IsBuffering
        {
            get
            {
                CheckDisposed();
#if !ULTIMATEREPLAY_DISABLE_THREADING
                return threadTasks.Count > 0;
#else
                return false;
#endif
            }
        }

        // Constructor
        protected ReplayStreamStorage(string replayName = null, bool useSegmentCompression = false): base(replayName)
        {
            this.useSegmentCompression = useSegmentCompression;
#if !ULTIMATEREPLAY_DISABLE_THREADING
            // Start running user task
            ThreadPool.QueueUserWorkItem(StreamingThreadMain);
#endif
        }

        // Methods
        protected abstract void ThreadWriteReplayHeader(ReplayStreamHeader header);
        protected abstract void ThreadWriteReplaySegment(ReplaySegment segment);
        protected abstract void ThreadWriteReplaySegmentTable(ReplaySegmentTable table);
        protected abstract void ThreadWriteReplayPersistentData(ReplayPersistentData data);
        protected abstract void ThreadWriteReplayMetadata(ReplayMetadata metadata);
        protected abstract void ThreadReadReplayHeader(ref ReplayStreamHeader header);
        protected abstract void ThreadReadReplaySegment(ref ReplaySegment segment, int segmentID);
        protected abstract void ThreadReadReplaySegmentTable(ref ReplaySegmentTable table);
        protected abstract void ThreadReadReplayPersistentData(ref ReplayPersistentData data);
        protected abstract void ThreadReadReplayMetadata(Type metadataType, ref ReplayMetadata metadata);
        protected virtual void OnStreamOpenWrite(Stream writeStream) => throw new System.NotImplementedException();
        protected virtual void OnStreamOpenRead(Stream readStream) => throw new System.NotImplementedException();
        protected virtual void OnStreamCommit(Stream writeStream) => throw new System.NotImplementedException();
        protected virtual void OnStreamSeek(Stream stream, long offset) => throw new System.NotImplementedException();
        public void LoadStreamCompletely() => throw new System.NotImplementedException();
        public ReplayAsyncOperation LoadStreamCompletelyAsync() => throw new System.NotImplementedException();
        public override ReplaySnapshot FetchSnapshot(int sequenceID) => throw new System.NotImplementedException();
        public override ReplaySnapshot FetchSnapshot(float timeStamp) => throw new System.NotImplementedException();
        public override void StoreSnapshot(ReplaySnapshot state) => throw new System.NotImplementedException();
        public override void Prepare(ReplayStorageAction mode) => throw new System.NotImplementedException();
        protected override void OnDispose() => throw new System.NotImplementedException();
#endif
        public string ToJsonString(Encoding encoding = null) => throw new System.NotImplementedException();
        public byte[] ToBytes() => throw new System.NotImplementedException();
        //public ReplayAsyncOperation<byte[]> ToBytesAsync()
        //{
        //    // Check for locked
        //    if (IsLocked == true)
        //        throw new InvalidOperationException("Storage is currently in use by another operation");
        //    // Create temp storage
        //    using (MemoryStream stream = new MemoryStream())
        //    {
        //        // Create temp storage
        //        ReplayStreamStorage tempStorage = FromStreamBinary(stream);
        //        // Perform copy
        //        ReplayAsyncOperation async = CopyToAsync(tempStorage);
        //        // Get bytes
        //        return stream.ToArray();
        //    }
        //}
        public static ReplayMetadata ReadMetadataOnly(Stream stream, ReplayStreamType streamType = ReplayStreamType.Default) => throw new System.NotImplementedException();
        public static T ReadMetadataOnly<T>(Stream stream, ReplayStreamType streamType = ReplayStreamType.Default)
            where T : ReplayMetadata => throw new System.NotImplementedException();
        public static ReplayAsyncOperation<ReplayMetadata> ReadMetadataOnlyAsync(Stream stream, ReplayStreamType type = ReplayStreamType.Default) => throw new System.NotImplementedException();
        public static ReplayAsyncOperation<T> ReadMetadataOnlyAsync<T>(Stream stream, ReplayStreamType streamType = ReplayStreamType.Default)
            where T : ReplayMetadata => throw new System.NotImplementedException();
        public static ReplayStreamStorage ReadStreamCompletely(Stream stream, ReplayStreamType streamType = ReplayStreamType.Default) => throw new System.NotImplementedException();
        public static ReplayStreamStorage ReadBytesCompletely(byte[] bytes) => throw new System.NotImplementedException();
        public static ReplayStreamStorage ReadBytesCompletely(byte[] bytes, int index, int count) => throw new System.NotImplementedException();
        public static ReplayAsyncOperation<ReplayStreamStorage> ReadStreamCompletelyAsync(Stream stream, ReplayStreamType streamType = ReplayStreamType.Default) => throw new System.NotImplementedException();
        public static ReplayAsyncOperation<ReplayStreamStorage> ReadBytesCompletelyAsync(byte[] bytes) => throw new System.NotImplementedException();
        public static ReplayAsyncOperation<ReplayStreamStorage> ReadBytesCompletelyAsync(byte[] bytes, int index, int count) => throw new System.NotImplementedException();
        public static ReplayStreamStorage FromStream(Stream stream, string replayName = null, ReplayStreamType streamType = ReplayStreamType.Default, bool useSegmentCompression = true, CompressionLevel blockCompressionLevel = CompressionLevel.Optimal, bool includeOptionalProperties = false) => throw new System.NotImplementedException();
        public static ReplayStreamStorage FromStreamBinary(Stream stream, string replayName = null, bool useSegmentCompression = true, CompressionLevel blockCompressionLevel = CompressionLevel.Optimal) => throw new System.NotImplementedException();
        public static ReplayStreamStorage FromStreamJson(Stream stream, string replayName = null, bool includeOptionalProperties = false) => throw new System.NotImplementedException();
#if !ULTIMATERPLAY_DISABLE_BSON
        public static ReplayStreamStorage FromStreamBson(Stream stream, string replayName = null, bool includeOptionalProperties = false) => throw new System.NotImplementedException();
#endif
        public static ReplayStreamStorage FromJsonString(string json, Encoding encoding = null) => throw new System.NotImplementedException();
        public static ReplayStreamStorage FromBytes(byte[] bytes) => throw new System.NotImplementedException();
        public static ReplayStreamStorage FromBytes(byte[] bytes, int index, int count) => throw new System.NotImplementedException();
    }
}