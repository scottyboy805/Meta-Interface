/// <summary>
/// This source file was auto-generated by a tool - Any changes may be overwritten!
/// From Unity assembly definition: UltimateReplay.dll
/// From source file: Assets/Ultimate Replay 3.0/Scripts/Runtime/Storage/ReplayState.cs
/// </summary>
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using UltimateReplay.Lifecycle;
using UltimateReplay.Storage;
using UnityEngine;

namespace UltimateReplay
{
    /// <summary>
    /// A <see cref = "ReplayState"/> allows replay objects to serialize and deserialize their data.
    /// See <see cref = "IReplaySerialize"/>. 
    /// </summary>
    public sealed partial class ReplayState : IDisposable, IReplayReusable, IReplaySerialize, IReplaySnapshotStorable, IReplayTokenSerialize
    {
        // Public
        public static readonly ReplayInstancePool<ReplayState> pool;
        // Properties
        /// <summary>
        /// Returns true if the state contains any more data.
        /// </summary>
        public bool CanRead
        {
            get => throw new System.NotImplementedException();
        }

        /// <summary>
        /// Returns true if the read pointer is at the end of the buffered data or false if there is still data to be read.
        /// </summary>
        public bool EndRead
        {
            get => throw new System.NotImplementedException();
        }

        /// <summary>
        /// Returns the size of the object state in bytes.
        /// </summary>
        public int Size
        {
            get => throw new System.NotImplementedException();
        }

        ReplaySnapshotStorableType IReplaySnapshotStorable.StorageType
        {
            get => throw new System.NotImplementedException();
        }

        /// <summary>
        /// Get the data hash for the current data stored in this state.
        /// </summary>
        public long DataHash
        {
            get => throw new System.NotImplementedException();
        }

        /// <summary>
        /// The current stored data as a hes string representation.
        /// </summary>
        [ReplayTokenSerialize("Raw Data")]
        public string AsHexString
        {
            get => throw new System.NotImplementedException();
            set => throw new System.NotImplementedException();
        }

        // Methods
        IEnumerable<ReplayToken> IReplayTokenSerialize.GetSerializeTokens(bool includeOptional) => throw new System.NotImplementedException();
        void IReplayReusable.Initialize() => throw new System.NotImplementedException();
        public void InitializeFromData(byte[] stateData) => throw new System.NotImplementedException();
        /// <summary>
        /// Release all data stored in this state and return this instance to the pool to be used by another operation.
        /// </summary>
        public void Dispose() => throw new System.NotImplementedException();
        /// <summary>
        /// Make sure that the state is capable of storing the specified amount of bytes.
        /// </summary>
        /// <param name = "size">The total required size in bytes</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnsureCapacity(int size) => throw new System.NotImplementedException();
        /// <summary>
        /// Prepares the state for read operations by seeking the read pointer back to the start.
        /// </summary>
        public void PrepareForRead() => throw new System.NotImplementedException();
        /// <summary>
        /// Clears all buffered data from this <see cref = "ReplayState"/> and resets its state.
        /// </summary>
        public void Clear() => throw new System.NotImplementedException();
        /// <summary>
        /// Get the string representation of this state.
        /// </summary>
        /// <returns></returns>
        public override string ToString() => throw new System.NotImplementedException();
        /// <summary>
        /// Get the <see cref = "ReplayState"/> data as a byte array. 
        /// </summary>
        /// <returns>A byte array of data</returns>
        public byte[] ToArray() => throw new System.NotImplementedException();
        /// <summary>
        /// Check if the specified state contains the same data as this state.
        /// Not suitable for high performance applications.
        /// Better to compare <see cref = "DataHash"/> for better performance if suitable.
        /// </summary>
        /// <param name = "other">The state to compare against</param>
        /// <returns>True if the data is equal or false if not</returns>
        public bool IsDataEqual(ReplayState other) => throw new System.NotImplementedException();
        /// <summary>
        /// Copy all data to the target <see cref = "ReplayState"/>.
        /// All state information such as <see cref = "dataHash"/> and <see cref = "readPointer"/> will be maintained.
        /// This <see cref = "ReplayState"/> must not be empty (Must contain data) otherwise this method will return false.
        /// The destination <see cref = "ReplayState"/> must be empty otherwise this method will return false.
        /// </summary>
        /// <param name = "destination"></param>
        /// <returns>True if the copy was successful or false if not</returns>
        /// <exception cref = "ArgumentNullException">Destination state is null</exception>
        /// <exception cref = "ObjectDisposedException">This <see cref = "ReplayState"/> or destination <see cref = "ReplayState"/> is disposed</exception>
        public bool CopyTo(ReplayState destination) => throw new System.NotImplementedException();
        /// <summary>
        /// Append all data from the specified state.
        /// This state will retain all original data and will have the specified data stored in addition.
        /// </summary>
        /// <param name = "data">The target state to append</param>
        public void Append(ReplayState data) => throw new System.NotImplementedException();
        void IReplaySerialize.OnReplaySerialize(ReplayState state) => throw new System.NotImplementedException();
        void IReplaySerialize.OnReplayDeserialize(ReplayState state) => throw new System.NotImplementedException();
        void IReplayStreamSerialize.OnReplayStreamSerialize(BinaryWriter writer) => throw new System.NotImplementedException();
        void IReplayStreamSerialize.OnReplayStreamDeserialize(BinaryReader reader) => throw new System.NotImplementedException();
        /// <summary>
        /// Read an additional replay state from the internal stored data.
        /// </summary>
        /// <returns></returns>
        public ReplayState ReadState() => throw new System.NotImplementedException();
        /// <summary>
        /// Check if the specified type can be serialized into a replay state.
        /// </summary>
        /// <param name = "type">The type to check</param>
        /// <returns>True if the type can be serialized</returns>
        public static bool IsTypeSerializable(Type type) => throw new System.NotImplementedException();
        /// <summary>
        /// Check if the specified generic type can be serialized into a replay state.
        /// </summary>
        /// <typeparam name = "T">The generic type to check</typeparam>
        /// <returns>True if the generic type can be serialized</returns>
        public static bool IsTypeSerializable<T>() => throw new System.NotImplementedException();
        public static MethodInfo GetSerializeMethod(Type type) => throw new System.NotImplementedException();
        public static MethodInfo GetSerializeMethod<T>() => throw new System.NotImplementedException();
        public static MethodInfo GetDeserializeMethod(Type type) => throw new System.NotImplementedException();
        public static MethodInfo GetDeserializeMethod<T>() => throw new System.NotImplementedException();
        public static ReplayState FromByteArray(byte[] rawStateData) => throw new System.NotImplementedException();
    }
}