/// <summary>
/// This source file was auto-generated by a tool - Any changes may be overwritten!
/// From Unity assembly definition: UltimateReplay.dll
/// From source file: Assets/Ultimate Replay 3.0/Scripts/Runtime/Storage/ReplayState.cs
/// </summary>
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Reflection;
using System.Runtime.CompilerServices;
using UltimateReplay.Lifecycle;
using UltimateReplay.Storage;
using UnityEngine;

namespace UltimateReplay
{
    /// <summary>
    /// A <see cref = "ReplayState"/> allows replay objects to serialize and deserialize their data.
    /// See <see cref = "IReplaySerialize"/>. 
    /// </summary>
    public sealed partial class ReplayState : IDisposable, IReplayReusable, IReplaySerialize, IReplaySnapshotStorable, IReplayTokenSerialize
    {
        // Public
        public static readonly ReplayInstancePool<ReplayState> pool;
        // Properties
        /// <summary>
        /// Returns true if the state contains any more data.
        /// </summary>
        public bool CanRead
        {
            get
            {
                CheckDisposed();
                return dataSize > 0;
            }
        }

        /// <summary>
        /// Returns true if the read pointer is at the end of the buffered data or false if there is still data to be read.
        /// </summary>
        public bool EndRead
        {
            get
            {
                CheckDisposed();
                return readPointer >= Size;
            }
        }

        /// <summary>
        /// Returns the size of the object state in bytes.
        /// </summary>
        public int Size
        {
            get
            {
                CheckDisposed();
                return dataSize;
            }
        }

        /// <summary>
        /// Get the data hash for the current data stored in this state.
        /// </summary>
        public long DataHash
        {
            get
            {
                // Check for disposed
                CheckDisposed();
                return FastDataHash;
            }
        }

        /// <summary>
        /// The current stored data as a hes string representation.
        /// </summary>
        [ReplayTokenSerialize("Raw Data")]
        public string AsHexString
        {
            get
            {
                // Check for easy case
                if (dataSize == 0)
                    return string.Empty;
                // Encode as hex string
                return HexConverter.GetHexString(bytes, 0, dataSize);
            }

            set
            {
                // Clear and reset
                dataSize = 0;
                readPointer = 0;
                dataHash = -1;
                // Check for null of empty
                if (string.IsNullOrEmpty(value) == true)
                    return;
                // Store data size
                dataSize = value.Length / 2;
                // Ensure capacity
                EnsureCapacity(dataSize);
                try
                {
                    // Convert string into data bytes
                    HexConverter.GetHexBytes(value, bytes, 0);
                }
                catch
                {
                    dataSize = 0;
                    readPointer = -1;
                    throw;
                }
            }
        }

        // Constructor
        static ReplayState()
        {
            foreach (MethodInfo declaredMethod in typeof(ReplayState).GetMethods(BindingFlags.Instance | BindingFlags.Public))
            {
                if (declaredMethod.Name == "Write")
                {
                    if (declaredMethod.GetParameters().Length == 1)
                    {
                        // Get param type
                        Type paramType = declaredMethod.GetParameters()[0].ParameterType;
                        // Check for by reference - get type without the by reference qualifier
                        if (paramType.IsByRef == true)
                            paramType = paramType.GetElementType();
                        // Register the parameter type
                        serializeMethods.Add(paramType, declaredMethod);
                    }
                }
                else if (declaredMethod.Name.StartsWith("Read") == true)
                {
                    if (declaredMethod.ReturnType != typeof(void) && declaredMethod.GetParameters().Length == 0 && deserializeMethods.ContainsKey(declaredMethod.ReturnType) == false)
                    {
                        deserializeMethods.Add(declaredMethod.ReturnType, declaredMethod);
                    }
                }
            }
        }

        /// <summary>
        /// Create an empty <see cref = "ReplayState"/> that can be written to. 
        /// </summary>
        private ReplayState()
        {
        }

        public void InitializeFromData(byte[] stateData) => throw new System.NotImplementedException();
        /// <summary>
        /// Release all data stored in this state and return this instance to the pool to be used by another operation.
        /// </summary>
        public void Dispose() => throw new System.NotImplementedException();
        /// <summary>
        /// Make sure that the state is capable of storing the specified amount of bytes.
        /// </summary>
        /// <param name = "size">The total required size in bytes</param>
        [MethodImpl(MethodImplOptions.AggressiveInlining)]
        public void EnsureCapacity(int size) => throw new System.NotImplementedException();
        /// <summary>
        /// Prepares the state for read operations by seeking the read pointer back to the start.
        /// </summary>
        public void PrepareForRead() => throw new System.NotImplementedException();
        /// <summary>
        /// Clears all buffered data from this <see cref = "ReplayState"/> and resets its state.
        /// </summary>
        public void Clear() => throw new System.NotImplementedException();
        /// <summary>
        /// Get the string representation of this state.
        /// </summary>
        /// <returns></returns>
        public override string ToString() => throw new System.NotImplementedException();
        /// <summary>
        /// Get the <see cref = "ReplayState"/> data as a byte array. 
        /// </summary>
        /// <returns>A byte array of data</returns>
        public byte[] ToArray() => throw new System.NotImplementedException();
        /// <summary>
        /// Check if the specified state contains the same data as this state.
        /// Not suitable for high performance applications.
        /// Better to compare <see cref = "DataHash"/> for better performance if suitable.
        /// </summary>
        /// <param name = "other">The state to compare against</param>
        /// <returns>True if the data is equal or false if not</returns>
        public bool IsDataEqual(ReplayState other) => throw new System.NotImplementedException();
        /// <summary>
        /// Copy all data to the target <see cref = "ReplayState"/>.
        /// All state information such as <see cref = "dataHash"/> and <see cref = "readPointer"/> will be maintained.
        /// This <see cref = "ReplayState"/> must not be empty (Must contain data) otherwise this method will return false.
        /// The destination <see cref = "ReplayState"/> must be empty otherwise this method will return false.
        /// </summary>
        /// <param name = "destination"></param>
        /// <returns>True if the copy was successful or false if not</returns>
        /// <exception cref = "ArgumentNullException">Destination state is null</exception>
        /// <exception cref = "ObjectDisposedException">This <see cref = "ReplayState"/> or destination <see cref = "ReplayState"/> is disposed</exception>
        public bool CopyTo(ReplayState destination) => throw new System.NotImplementedException();
        /// <summary>
        /// Append all data from the specified state.
        /// This state will retain all original data and will have the specified data stored in addition.
        /// </summary>
        /// <param name = "data">The target state to append</param>
        public void Append(ReplayState data) => throw new System.NotImplementedException();
        /// <summary>
        /// Read an additional replay state from the internal stored data.
        /// </summary>
        /// <returns></returns>
        public ReplayState ReadState() => throw new System.NotImplementedException();
        /// <summary>
        /// Check if the specified type can be serialized into a replay state.
        /// </summary>
        /// <param name = "type">The type to check</param>
        /// <returns>True if the type can be serialized</returns>
        public static bool IsTypeSerializable(Type type) => throw new System.NotImplementedException();
        /// <summary>
        /// Check if the specified generic type can be serialized into a replay state.
        /// </summary>
        /// <typeparam name = "T">The generic type to check</typeparam>
        /// <returns>True if the generic type can be serialized</returns>
        public static bool IsTypeSerializable<T>() => throw new System.NotImplementedException();
        public static MethodInfo GetSerializeMethod(Type type) => throw new System.NotImplementedException();
        public static MethodInfo GetSerializeMethod<T>() => throw new System.NotImplementedException();
        public static MethodInfo GetDeserializeMethod(Type type) => throw new System.NotImplementedException();
        public static MethodInfo GetDeserializeMethod<T>() => throw new System.NotImplementedException();
        public static ReplayState FromByteArray(byte[] rawStateData) => throw new System.NotImplementedException();
    }
}