/// <summary>
/// This source file was auto-generated by a tool - Any changes may be overwritten!
/// From Unity assembly definition: UltimateReplay.dll
/// From source file: Assets/Ultimate Replay 3.0/Scripts/Runtime/Storage/ReplaySegment.cs
/// </summary>
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UltimateReplay.Lifecycle;

namespace UltimateReplay.Storage
{
    public sealed class ReplaySegment : IDisposable, IReplayReusable, IReplayStreamSerialize, IReplayTokenSerialize
    {
        // Public
        public static readonly ReplayInstancePool<ReplaySegment> pool;
        // Properties
        public int SegmentID
        {
            get
            {
                return segmentID;
            }
        }

        public int SnapshotCapacity
        {
            get
            {
                return snapshotCapacity;
            }
        }

        public ReplaySnapshot StartSnapshot
        {
            get
            {
                return start;
            }
        }

        public ReplaySnapshot EndSnapshot
        {
            get
            {
                return end;
            }
        }

        public float StartTimeStamp
        {
            get
            {
                // Get the time stamp
                if (start != null)
                    return start.TimeStamp;
                // Error
                return -1f;
            }
        }

        public float EndTimeStamp
        {
            get
            {
                // Get the time stamp
                if (end != null)
                    return end.TimeStamp;
                // Error
                return -1f;
            }
        }

        public int StartSequenceID
        {
            get
            {
                // Get the sequence id
                if (start != null)
                    return start.SequenceID;
                // Error
                return -1;
            }
        }

        public int EndSequenceID
        {
            get
            {
                // Get the sequence id
                if (end != null)
                    return end.SequenceID;
                // Error
                return -1;
            }
        }

        public int SnapshotCount
        {
            get
            {
                return snapshots.Count;
            }
        }

        public IEnumerable<ReplaySnapshot> Snapshots
        {
            get
            {
                return snapshots.Values;
            }
        }

        public bool IsEmpty
        {
            get
            {
                return snapshots.Count == 0;
            }
        }

        public bool IsFull
        {
            get
            {
                return snapshots.Count == snapshotCapacity;
            }
        }

        public bool IsCompressed
        {
            get
            {
                return isCompressed;
            }
        }

        // Constructor
        public ReplaySegment()
        {
            snapshots = new Dictionary<int, ReplaySnapshot>();
        }

        public ReplaySegment(int segmentID, int snapshotCount)
        {
            // Check for count exceeded
            if (snapshotCount > byte.MaxValue)
                throw new ArgumentException("Snapshot count cannot exceed '255'");
            this.segmentID = segmentID;
            this.snapshotCapacity = snapshotCount;
            this.snapshots = new Dictionary<int, ReplaySnapshot>(snapshotCount);
        }

        public void Dispose() => throw new System.NotImplementedException();
        public void AddSnapshot(ReplaySnapshot snapshot) => throw new System.NotImplementedException();
        public ReplaySnapshot FetchSnapshot(float timeStamp) => throw new System.NotImplementedException();
        public ReplaySnapshot FetchSnapshot(int sequenceId) => throw new System.NotImplementedException();
        /// <summary>
        /// Segment compression algorithm.
        /// Lossless algorithm which works by replacing replay state data that uses a hash seen in previous snapshots in this segment with a pointer object that links to the former snapshot data via index.
        /// This means that is snapshot data is unchanged for a few snapshots, it is possible to eliminate many replay state containers since they contain duplicate data.
        /// </summary>
        public void CompressSegment() => throw new System.NotImplementedException();
        public void DecompressSegment() => throw new System.NotImplementedException();
    }
}