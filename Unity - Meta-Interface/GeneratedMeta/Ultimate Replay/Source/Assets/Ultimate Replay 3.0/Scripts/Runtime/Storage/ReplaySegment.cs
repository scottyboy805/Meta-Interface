/// <summary>
/// This source file was auto-generated by a tool - Any changes may be overwritten!
/// From Unity assembly definition: UltimateReplay.dll
/// From source file: Assets/Ultimate Replay 3.0/Scripts/Runtime/Storage/ReplaySegment.cs
/// </summary>
using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using UltimateReplay.Lifecycle;

namespace UltimateReplay.Storage
{
    public sealed class ReplaySegment : IDisposable, IReplayReusable, IReplayStreamSerialize, IReplayTokenSerialize
    {
        // Public
        public static readonly ReplayInstancePool<ReplaySegment> pool;
        // Properties
        public int SegmentID
        {
            get => throw new System.NotImplementedException();
        }

        public int SnapshotCapacity
        {
            get => throw new System.NotImplementedException();
        }

        public ReplaySnapshot StartSnapshot
        {
            get => throw new System.NotImplementedException();
        }

        public ReplaySnapshot EndSnapshot
        {
            get => throw new System.NotImplementedException();
        }

        public float StartTimeStamp
        {
            get => throw new System.NotImplementedException();
        }

        public float EndTimeStamp
        {
            get => throw new System.NotImplementedException();
        }

        public int StartSequenceID
        {
            get => throw new System.NotImplementedException();
        }

        public int EndSequenceID
        {
            get => throw new System.NotImplementedException();
        }

        public int SnapshotCount
        {
            get => throw new System.NotImplementedException();
        }

        public IEnumerable<ReplaySnapshot> Snapshots
        {
            get => throw new System.NotImplementedException();
        }

        public bool IsEmpty
        {
            get => throw new System.NotImplementedException();
        }

        public bool IsFull
        {
            get => throw new System.NotImplementedException();
        }

        public bool IsCompressed
        {
            get => throw new System.NotImplementedException();
        }

        // Constructor
        public ReplaySegment() => throw new System.NotImplementedException();
        public ReplaySegment(int segmentID, int snapshotCount) => throw new System.NotImplementedException();
        // Methods
        IEnumerable<ReplayToken> IReplayTokenSerialize.GetSerializeTokens(bool includeOptional) => throw new System.NotImplementedException();
        public void Dispose() => throw new System.NotImplementedException();
        void IReplayReusable.Initialize() => throw new System.NotImplementedException();
        public void AddSnapshot(ReplaySnapshot snapshot) => throw new System.NotImplementedException();
        public ReplaySnapshot FetchSnapshot(float timeStamp) => throw new System.NotImplementedException();
        public ReplaySnapshot FetchSnapshot(int sequenceId) => throw new System.NotImplementedException();
        /// <summary>
        /// Segment compression algorithm.
        /// Lossless algorithm which works by replacing replay state data that uses a hash seen in previous snapshots in this segment with a pointer object that links to the former snapshot data via index.
        /// This means that is snapshot data is unchanged for a few snapshots, it is possible to eliminate many replay state containers since they contain duplicate data.
        /// </summary>
        public void CompressSegment() => throw new System.NotImplementedException();
        public void DecompressSegment() => throw new System.NotImplementedException();
        void IReplayStreamSerialize.OnReplayStreamSerialize(BinaryWriter writer) => throw new System.NotImplementedException();
        void IReplayStreamSerialize.OnReplayStreamDeserialize(BinaryReader reader) => throw new System.NotImplementedException();
    }
}