/// <summary>
/// This source file was auto-generated by a tool - Any changes may be overwritten!
/// From Unity assembly definition: UltimateReplay.dll
/// From source file: Assets/Ultimate Replay 3.0/Scripts/Runtime/ReplayPlaybackOperation.cs
/// </summary>
using System;
using System.Collections;
using UltimateReplay.Storage;
using UnityEngine;
using UnityEngine.Events;

namespace UltimateReplay
{
    /// <summary>
    /// Represents a playback node that can be used to calculate playback offsets.
    /// </summary>
    public enum PlaybackOrigin
    {
        /// <summary>
        /// The start of the playback sequence.
        /// </summary>
        Start,
        /// <summary>
        /// The current frame in the playback sequence.
        /// </summary>
        Current,
        /// <summary>
        /// The end of the playback sequence.
        /// </summary>
        End,
    }

    /// <summary>
    /// Used to indicate what should happen when the end of a replay is reached.
    /// </summary>
    public enum PlaybackEndBehaviour
    {
        /// <summary>
        /// The playback service should automatically end the replay and trigger and playback end events listeners.
        /// The active replay scene will also be reverted to live mode causing physics objects and scripts to be re-activated.
        /// </summary>
        EndPlayback,
        /// <summary>
        /// The playback service should stop the playback and return to the start of the replay.
        /// The active replay scene will remain in playback mode and you will need to call <see cref = "ReplayManager.StopPlayback(ref ReplayHandle, bool)"/> manually to end playback.
        /// </summary>
        StopPlayback,
        /// <summary>
        /// The playback service should loop back around to the start of the replay and continue playing.
        /// The replay will play indefinitely until <see cref = "ReplayManager.StopPlayback(ref ReplayHandle, bool)"/> is called.
        /// </summary>
        LoopPlayback
    }

    /// <summary>
    /// The playback direction used during replay playback.
    /// </summary>
    public enum PlaybackDirection
    {
        /// <summary>
        /// The replay should be played back in normal mode.
        /// </summary>
        Forward,
        /// <summary>
        /// The replay should be played back in reverse mode.
        /// </summary>
        Backward,
    }

    /// <summary>
    /// The playback seek behaviour that will be used when seeking to a certain time stamp.
    /// </summary>
    public enum PlaybackSeekSnap
    {
        /// <summary>
        /// The replay system will interpolate between frames if possible when seeking.
        /// Seeking will give a smooth seamless transition if replay components support interpolation.
        /// </summary>
        Smooth,
        /// <summary>
        /// The replay system will constrain seeking to snapshot frames.
        /// Can give a notchy effect when seeking as the time stamp snaps to the nearest snapshot frame.
        /// </summary>
        SnapToFrame,
    }

    public enum RestoreSceneMode
    {
        /// <summary>
        /// Restore the scene state to just before the replay started.
        /// </summary>
        RestoreState,
        /// <summary>
        /// Do not restore the scene state and keep replay objects in their current state at the time the replay ends.
        /// Use this option for rewind time effect for example to keep playing the game from a certain point in the replay.
        /// </summary>
        KeepState,
    }

    /// <summary>
    /// Represents a dedicated playback operation in progress.
    /// Provides access to all playback replated API's for a specific playback operation.
    /// </summary>
    public sealed class ReplayPlaybackOperation : ReplayOperation, IDisposable
    {
        // Events
        public UnityEvent OnPlaybackEnd;
        public UnityEvent OnPlaybackStop;
        public UnityEvent OnPlaybackLooped;
        // Public
        /// <summary>
        /// The default playback fps rate.
        /// </summary>
        public const float defaultPlaybackRate = 60f;
        // Properties
        /// <summary>
        /// Check if this playback operation has been disposed.
        /// A playback operation becomes disposed when playback has been stopped, at which point the API becomes unusable.
        /// </summary>
        public override bool IsDisposed
        {
            get => throw new System.NotImplementedException();
        }

        /// <summary>
        /// Get the <see cref = "ReplayUpdateMode"/> for this replay operation.
        /// This value determines at what stage in the Unity game loop the playback operation is updated. 
        /// </summary>
        public override ReplayUpdateMode UpdateMode
        {
            get => throw new System.NotImplementedException();
        }

        /// <summary>
        /// Get the <see cref = "ReplayPlaybackOptions"/> for this replay operation.
        /// </summary>
        public ReplayPlaybackOptions Options
        {
            get => throw new System.NotImplementedException();
        }

        /// <summary>
        /// Get the duration of the replay.
        /// </summary>
        public float Duration
        {
            get => throw new System.NotImplementedException();
        }

        /// <summary>
        /// Get the current playback time of this operation in seconds.
        /// Playback time will always be between 0 and <see cref = "Duration"/>.
        /// To change the current playback time use <see cref = "SeekPlayback(float, PlaybackOrigin, bool)"/> or <see cref = "SeekPlaybackNormalized(float, bool)"/>.
        /// </summary>
        public float PlaybackTime
        {
            get => throw new System.NotImplementedException();
        }

        /// <summary>
        /// Get the current normalized playback time of this operation.
        /// The normalized time will always be between 0 and 1, where 0 represents that start of the replay, 1 represents the end of the relay, and 0.5 represents the middle of the replay.
        /// Can be used to easily seek to common offsets such as (middle) without needing to calculate the time based on <see cref = "Duration"/>.
        /// </summary>
        public float PlaybackTimeNormalized
        {
            get => throw new System.NotImplementedException();
        }

        /// <summary>
        /// The current playback time scale which represents the speed at which playback will occur.
        /// The playback time scale is used as a multiplier so a value of 1 represents normal speed, 2 represents twice the speed, and 0.5 represents half the speed.
        /// </summary>
        public float PlaybackTimeScale
        {
            get => throw new System.NotImplementedException();
            set => throw new System.NotImplementedException();
        }

        /// <summary>
        /// The current playback direction.
        /// Use <see cref = "PlaybackDirection.Backward"/> to replay in reverse.
        /// </summary>
        public PlaybackDirection PlaybackDirection
        {
            get => throw new System.NotImplementedException();
            set => throw new System.NotImplementedException();
        }

        /// <summary>
        /// Get the current playback end behaviour which determines what will happen when the replay reaches the end.
        /// By default, playback will end and the associated replay scene will switch back to live mode so that gameplay can resume.
        /// </summary>
        public PlaybackEndBehaviour EndBehaviour
        {
            get => throw new System.NotImplementedException();
        }

        /// <summary>
        /// The current playback seek snap setting.
        /// Seek snap determines how seeking behaviours in relation to the snapshots that are available from the recording.
        /// <see cref = "PlaybackSeekSnap.SnapToFrame"/> means that the replay system will clamp to the nearest snapshot. This gives a snappy effect while drag seeking as the replay jumps to the nearest recorded snapshot.
        /// <see cref = "PlaybackSeekSnap.Smooth"/> means that the replay system may interpolate between multiple snapshots if the time values falls between 2 snapshots. This gives a smooth replay while drag seeking.
        /// </summary>
        public PlaybackSeekSnap SeekSnap
        {
            get => throw new System.NotImplementedException();
            set => throw new System.NotImplementedException();
        }

        /// <summary>
        /// The current scene restore mode which determines what will happen to the associated replay objects when playback ends.
        /// <see cref = "RestoreSceneMode.KeepState"/> means that replay objects will maintain their current state when the replay ends, meaning that gameplay can continue from the current playback positions.
        /// <see cref = "RestoreSceneMode.RestoreState"/> means that the replay system will restore all replay objects to their original state immediately before playback began.
        /// </summary>
        public RestoreSceneMode RestoreSceneMode
        {
            get => throw new System.NotImplementedException();
            set => throw new System.NotImplementedException();
        }

        /// <summary>
        /// Returns a value indicating whether playback is in progress and the playback is not currently paused.
        /// </summary>
        public bool IsReplaying
        {
            get => throw new System.NotImplementedException();
        }

        /// <summary>
        /// Returns a value indicating whether the playback is currently paused.
        /// </summary>
        public bool IsPlaybackPaused
        {
            get => throw new System.NotImplementedException();
        }

        /// <summary>
        /// Returns a value indicating whether playback is in progress or if the playback is currently paused.
        /// </summary>
        public bool IsReplayingOrPaused
        {
            get => throw new System.NotImplementedException();
        }

        /// <summary>
        /// The target number of playback frames that will be simulated per second.
        /// Higher rates will allow for smooth and more accurate playback, but may have an additional performance hit.
        /// The replay system will not be able to playback faster than your current frame rate so there is no benefit in setting a value of '90' for example if you game will only run at 60 fps.
        /// Set this value to negative and the playback operation will run as fast as possible.
        /// Default value is 60fps.
        /// </summary>
        public float PlaybackRate
        {
            get => throw new System.NotImplementedException();
        }

        // Constructor
        internal ReplayPlaybackOperation(ReplayManager manager, ReplayScene scene, ReplayStorage storage, ReplayPlaybackOptions options): base(default, default, default) => throw new System.NotImplementedException();
        // Methods
        /// <summary>
        /// The main update call for this replay operation.
        /// Can be called manually if required, but if manually update is required then it is recommended to use <see cref = "ReplayManager.ReplayTick(float, ReplayUpdateMode)"/>.
        /// </summary>
        /// <param name = "delta">The amount of time in seconds that has passed since the last update</param>
        public override void ReplayTick(float delta) => throw new System.NotImplementedException();
        /// <summary>
        /// Dispose this replay operation.
        /// This will cause the playback to be stopped and this playback operation should no longer be used.
        /// </summary>
        public override void Dispose() => throw new System.NotImplementedException();
        /// <summary>
        /// Pause the current playback operation.
        /// Playback will not be updated but all associated replay objects will remain in playback mode.
        /// </summary>
        public void PausePlayback() => throw new System.NotImplementedException();
        /// <summary>
        /// Resume the current playback operation.
        /// The replay will carry on from the point at which it was paused. 
        /// </summary>
        public void ResumePlayback() => throw new System.NotImplementedException();
        /// <summary>
        /// Stop this playback operation.
        /// Playback will stop and this operation will be disposed so should no longed be used after this call.
        /// </summary>
        public void StopPlayback() => throw new System.NotImplementedException();
        /// <summary>
        /// Stop this playback operation after the specified amount of second has passed.
        /// Playback will stop after the specified time and this operation will be disposed so should no longed be used after this call.
        /// </summary>
        /// <param name = "delay">The amount of time in seconds to wait until the record operation is stopped</param>
        public void StopPlaybackDelayed(float delay) => throw new System.NotImplementedException();
        /// <summary>
        /// Jump to a new time stamp in the replay and update all replaying objects.
        /// The time stamp is specified in seconds and should usually be between 0 - <see cref = "Duration"/>, although negative values are allowed when using relative seeking from the current time stamp.
        /// You can specify a relative time offset if you wanted to seek + or - 5 seconds for example using the <see cref = "PlaybackOrigin"/> enum to specify the seek mode.
        /// Take a look at <see cref = "SeekPlaybackNormalized(float, bool)"/> if you want to seek using a normalized value between 0-1.
        /// Seeking will be performed smoothly by default meaning that interpolation may occur between 2 snapshots since the input time stamp is unlikely to exactly match any given snapshot time stamp. This behaviour can be disabled if required so that seeking will snap to the nearest snapshot using <see cref = "SeekSnap"/>.
        /// Seeking can mean that the replay will jump over many snapshots meaning that replay events and method may go uncalled during the seeking process which may or may not be desirable. You can force the replay system to trigger any such events or method calls that may have been missed using the <paramref name = "simulateMissedFrames"/> parameter. Note though that enabling this option can be extremely performance intensive so is only recommended for smaller replays with few replay objects.
        /// </summary>
        /// <param name = "time">The time in seconds to seek to, or to use as an offset depending upon the <paramref name = "origin"/> value></param>
        /// <param name = "origin">The origin where the seek should start from. Use <see cref = "PlaybackOrigin.Current"/> if you want to seek + or - a few seconds for example</param>
        /// <param name = "simulateMissedFrames">Should the missed frames between seek positions be simulated. NOT RECOMMENDED FOR LARGER REPLAYS</param>
        public void SeekPlayback(float time, PlaybackOrigin origin = PlaybackOrigin.Start, bool simulateMissedFrames = false) => throw new System.NotImplementedException();
        public void SeekPlaybackNormalized(float timeNormalized, bool simulateMissedFrames = false) => throw new System.NotImplementedException();
        /// <summary>
        /// Throw an exception if this playback operation has been disposed.
        /// </summary>
        /// <exception cref = "ObjectDisposedException">The replay operation was disposed</exception>
        protected override void CheckDisposed() => throw new System.NotImplementedException();
    }
}