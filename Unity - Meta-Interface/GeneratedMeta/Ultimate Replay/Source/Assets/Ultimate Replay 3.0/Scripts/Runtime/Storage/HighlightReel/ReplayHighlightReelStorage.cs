/// <summary>
/// This source file was auto-generated by a tool - Any changes may be overwritten!
/// From Unity assembly definition: UltimateReplay.dll
/// From source file: Assets/Ultimate Replay 3.0/Scripts/Runtime/Storage/HighlightReel/ReplayHighlightReelStorage.cs
/// </summary>
using System;
using System.Collections.Generic;

namespace UltimateReplay.Storage
{
    /// <summary>
    /// A special storage target that can combine multiple other storage sources into a single replay to create a highlight reel/montage.
    /// Useful for showing action replays in sequence or similar.
    /// </summary>
    public sealed class ReplayHighlightReelStorage : ReplayStorage
    {
        // Properties
        /// <summary>
        /// Does the storage target support read operations for playback mode.
        /// </summary>
        public override bool CanRead
        {
            get
            {
                CheckDisposed();
                return true;
            }
        }

        /// <summary>
        /// Does the storage target support write operations for record mode.
        /// </summary>
        public override bool CanWrite
        {
            get
            {
                CheckDisposed();
                return false;
            }
        }

        /// <summary>
        /// Get the duration in seconds that the stored recording lasts.
        /// </summary>
        public override float Duration
        {
            get
            {
                CheckDisposed();
                return duration;
            }
        }

        /// <summary>
        /// Get the amount of bytes that have been stored for the current recording.
        /// The number of bytes represents only the data recorded by the replay system and not actual memory usage.
        /// </summary>
        public override int MemorySize
        {
            get
            {
                CheckDisposed();
                return memorySize;
            }
        }

        /// <summary>
        /// Get the total number of <see cref = "ReplaySnapshot"/> stored in the current recording.
        /// </summary>
        public override int SnapshotSize
        {
            get
            {
                CheckDisposed();
                return snapshotCount;
            }
        }

        /// <summary>
        /// Get the size in bytes of all <see cref = "ReplayIdentity"/> stored in this recording.
        /// The byte size of <see cref = "ReplayIdentity"/> may be changed for better storage size vs max number of possible replay objects.
        /// </summary>
        public override int IdentitySize
        {
            get
            {
                CheckDisposed();
                return identitySize;
            }
        }

        // Constructor
        /// <summary>
        /// Create a new instance with the specified storage inputs to combine into a highlights reel.
        /// </summary>
        /// <param name = "highlights">A number of storage targets used to form a montage in the order specified</param>
        /// <param name = "disposeHighlights">True if all provided storage targets should also be disposed when this <see cref = "ReplayHighlightReelStorage"/> is disposed</param>
        /// <exception cref = "ArgumentNullException">One or more storage targets in the specified <see cref = "IEnumerable{T}"/> are null</exception>
        public ReplayHighlightReelStorage(IEnumerable<ReplayStorage> highlights, bool disposeHighlights = true)
        {
            identitySize = ReplayIdentity.byteSize;
            this.highlights.AddRange(highlights);
            this.disposeHighlights = disposeHighlights;
            // Update values
            foreach (ReplayStorage storage in highlights)
            {
                // Check for null
                if (storage == null)
                    throw new ArgumentNullException("highlights", "One or more elements in the collection are null");
                // Update info
                duration += storage.Duration;
                memorySize += storage.MemorySize;
                snapshotCount += storage.SnapshotSize;
            }
        }

        // Methods
        /// <summary>
        /// Called by the replay system when a lock should be created on this storage target, typically when a record or playback operation is started.
        /// Used to prevent other replay operations from accessing the same storage target.
        /// </summary>
        /// <param name = "operation">The <see cref = "ReplayOperation"/> that claimed the storage target</param>
        protected internal override void Lock(ReplayOperation operation) => throw new System.NotImplementedException();
        /// <summary>
        /// Called by the replay system when a lock should be released on this storage target, typically when a record or playback operation is ended.
        /// </summary>
        /// <param name = "operation">The <see cref = "ReplayOperation"/> that created the lock</param>
        protected internal override void Unlock(ReplayOperation operation) => throw new System.NotImplementedException();
        public override ReplaySnapshot FetchSnapshot(float timeStamp) => throw new System.NotImplementedException();
        public override ReplaySnapshot FetchSnapshot(int sequenceID) => throw new System.NotImplementedException();
        public override void Prepare(ReplayStorageAction mode) => throw new System.NotImplementedException();
        public override void StoreSnapshot(ReplaySnapshot state) => throw new System.NotImplementedException();
        protected override void OnDispose() => throw new System.NotImplementedException();
    }
}