/// <summary>
/// This source file was auto-generated by a tool - Any changes may be overwritten!
/// From Unity assembly definition: UltimateReplay.dll
/// From source file: Assets/Ultimate Replay 3.0/Scripts/Runtime/ReplayBehaviour.cs
/// </summary>
using System;
using System.Collections.Generic;
using System.Reflection;
using UnityEngine;
using UltimateReplay.ComponentData;

#if MIRROR
using Mirror;
#endif
#if UNITY_EDITOR
using UnityEditor;
#endif
namespace UltimateReplay
{
    /// <summary>
    /// This interface can be implemented by mono behaviour scripts in order to receive replay start and end events.
    /// It works in a similar way to the 'Start' or 'Update' method however you must explicitly implement the interface as opposed to using magic methods.
    /// This allows for slightly improved performance.
    /// </summary>
    
#if MIRROR && !ULTIMATEREPLAY_DISABLE_MIRROR
    public abstract class ReplayBehaviour : NetworkBehaviour
#else
    public abstract class ReplayBehaviour : MonoBehaviour
#endif
    {
        // Properties 
        /// <summary>
        /// Get the <see cref = "Core.ReplayIdentity"/> associated with this <see cref = "ReplayBehaviour"/>.  
        /// </summary>
        public ReplayIdentity ReplayIdentity
        {
            get
            {
                // Check for awake
                //CheckAwakeCalled();
                return replayIdentity;
            }

            set
            {
                // Check for awake
                //CheckAwakeCalled();
                replayIdentity = value;
            }
        }

        /// <summary>
        /// Get the managing <see cref = "ReplayObject"/>.
        /// </summary>
        public ReplayObject ReplayObject
        {
            get
            {
                // Check for awake
                //CheckAwakeCalled();
                return replayObject.reference;
            }
        }

        public bool HasPersistentData
        {
            get
            {
                // Check for awake
                CheckAwakeCalled();
                return replayPersistentData != null && replayPersistentData.Size > 0;
            }
        }

        public ReplayState ReplayPersistentData
        {
            get
            {
                // Check for awake
                CheckAwakeCalled();
                // Create if required
                if (replayPersistentData == null)
                    replayPersistentData = ReplayState.pool.GetReusable();
                // Get instance
                return replayPersistentData;
            }
        }

        /// <summary>
        /// Get all <see cref = "ReplayVariable"/> associated with this <see cref = "ReplayBehaviour"/>.
        /// </summary>
        public IList<ReplayVariable> Variables
        {
            get
            {
                // Check for awake
                CheckAwakeCalled();
                if (variablesCount == -1)
                {
                    foreach (FieldInfo field in GetType().GetFields())
                    {
                        // Check for replay var attribute
                        if (field.IsDefined(typeof(ReplayVarAttribute), false) == true)
                        {
                            // Get the attribute
                            ReplayVarAttribute attribute = (ReplayVarAttribute)field.GetCustomAttributes(typeof(ReplayVarAttribute), false)[0];
                            // Create a new variable
                            ReplayVariable variable = new ReplayVariable(this, field, attribute);
                            // Add to collection
                            if (variables == null)
                                variables = new List<ReplayVariable>();
                            // Register the variable
                            variables.Add(variable);
                        }
                    }

                    // Cache item count
                    variablesCount = 0;
                    if (variables != null)
                        variablesCount = variables.Count;
                }

                return variables;
            }
        }

        /// <summary>
        /// Returns a value indicating whether this <see cref = "ReplayObject"/> has any <see cref = "ReplayVariable"/>.
        /// </summary>
        public bool HasVariables
        {
            get
            {
                // Check for awake
                CheckAwakeCalled();
                // Check fi variables have been initialized
                if (variablesCount != -1)
                    return variablesCount > 0;
                // Initialize by accessing the collection
                return Variables != null;
            }
        }

        /// <summary>
        /// Returns true if the active replay manager is currently recording the scene.
        /// Note: If recording is paused this value will still be true.
        /// </summary>
        public bool IsRecording
        {
            get
            {
                return ReplayObject.IsRecording;
            }
        }

        public bool IsRecordingPaused
        {
            get
            {
                return ReplayObject.IsRecordingPaused;
            }
        }

        public bool IsRecordingOrPaused
        {
            get
            {
                return ReplayObject.IsRecordingOrPaused;
            }
        }

        /// <summary>
        /// Returns true if the active replay manager is currently replaying a previous recording.
        /// Note: If playback is paused this value will still be true.
        /// </summary>
        public bool IsReplaying
        {
            get
            {
                return ReplayObject.IsReplaying;
            }
        }

        public bool IsPlaybackPaused
        {
            get
            {
                return ReplayObject.IsPlaybackPaused;
            }
        }

        public bool IsReplayingOrPaused
        {
            get
            {
                return ReplayObject.IsReplayingOrPaused;
            }
        }

        /// <summary>
        /// Get the current playback time in seconds.
        /// This <see cref = "ReplayBehaviour"/> must be attached to an object that is currently being replayed for this value to be valid.
        /// </summary>
        public float PlaybackTime
        {
            get
            {
                // Check for replaying
                if (ReplayObject.IsRecordingOrPaused == true)
                    return ReplayObject.PlaybackOperation.PlaybackTime;
                return 0f;
            }
        }

        public float PlaybackTimeNormalized
        {
            get
            {
                // Check for replaying
                if (ReplayObject.IsRecordingOrPaused == true)
                    return ReplayObject.PlaybackOperation.PlaybackTimeNormalized;
                return 0f;
            }
        }

        public float PlaybackTimeScale
        {
            get
            {
                // Check for replaying
                if (ReplayObject.IsReplayingOrPaused == true)
                    return ReplayObject.PlaybackOperation.PlaybackTimeScale;
                return 1f;
            }
        }

        /// <summary>
        /// Gets the current <see cref = "PlaybackDirection"/> of replay playback.
        /// </summary>
        public PlaybackDirection PlaybackDirection
        {
            get
            {
                // Check for replaying
                if (ReplayObject.IsRecordingOrPaused == true)
                    return ReplayObject.PlaybackOperation.PlaybackDirection;
                return PlaybackDirection.Forward;
            }
        }

        // Methods
        /// <summary>
        /// Called by Unity while in editor mode.
        /// Allows the unique id to be generated when the script is attached to an object.
        /// </summary>
        protected virtual void Reset() => throw new System.NotImplementedException();
        /// <summary>
        /// Called by Unity.
        /// </summary>
        protected virtual void Awake() => throw new System.NotImplementedException();
        protected virtual void OnDestroy() => throw new System.NotImplementedException();
        /// <summary>
        /// Called by Unity.
        /// Be sure to call this base method when overriding otherwise replay events will not be received.
        /// </summary>
        protected virtual void OnEnable() => throw new System.NotImplementedException();
        /// <summary>
        /// Called by Unity.
        /// Be sure to call this base method when overriding otherwise replay events will not be received.
        /// </summary>
        protected virtual void OnDisable() => throw new System.NotImplementedException();
        /// <summary>
        /// Called by the replay system when playback is about to start.
        /// You can disable game behaviour that should not run during playback in this method, such as player movement.
        /// </summary>
        protected virtual void OnReplayStart() => throw new System.NotImplementedException();
        /// <summary>
        /// Called by the replay system when playback has ended.
        /// You can re-enable game behaviour in this method to allow the gameplay to 'take over'
        /// </summary>
        protected virtual void OnReplayEnd() => throw new System.NotImplementedException();
        /// <summary>
        /// Called by the replay system when playback is about to be paused or resumed.
        /// </summary>
        /// <param name = "paused">True if playback is about to be paused or false if plyabck is about to be resumed</param>
        protected virtual void OnReplayPlayPause(bool paused) => throw new System.NotImplementedException();
        /// <summary>
        /// Called by the replay system during playback when cached values should be reset to safe default to avoid glitches or inaccuracies in the playback.
        /// </summary>
        protected virtual void OnReplayReset() => throw new System.NotImplementedException();
        /// <summary>
        /// Called by the replay system when non-recordable components should submit data to be recorded to the managing replay object. This method is ideal for recording variables, events, methods calls and similar.
        /// Update can be used instead however 'OnReplayCapture' is guarenteed to be called during the same frame that replay recordable data is serialized.
        /// </summary>
        protected virtual void OnReplayCapture() => throw new System.NotImplementedException();
        /// <summary>
        /// Called by the replay system every frame while playback is active.
        /// </summary>
        /// <param name = "t">A normalized value representing the progress between replay snapshots. Use this value for interpolation or similar smoothing passes</param>
        protected virtual void OnReplayUpdate(float t) => throw new System.NotImplementedException();
        /// <summary>
        /// Called by the replay system when an event has been received during playback.
        /// </summary>
        /// <param name = "replayEvent">The event that was received</param>
        protected virtual void OnReplayEvent(ushort eventID, ReplayState eventData) => throw new System.NotImplementedException();
        /// <summary>
        /// Called by the replay system when the object has been spawned from a prefab instance during playback.
        /// </summary>
        /// <param name = "position"></param>
        /// <param name = "rotation"></param>
        protected virtual void OnReplaySpawned(Vector3 position, Quaternion rotation) => throw new System.NotImplementedException();
        /// <summary>
        /// Force the <see cref = "ReplayIdentity"/> of this component to be regenerated.
        /// </summary>
        public void ForceRegenerateIdentity() => throw new System.NotImplementedException();
        /// <summary>
        /// Record the value of the specified <see cref = "ReplayVariable"/>.
        /// Should only be called when <see cref = "IsRecording"/> is true.
        /// The variable data will be recorded for a single frame. 
        /// To order to record a variable over time, simply call this method every frame.
        /// </summary>
        /// <param name = "variable"></param>
        public void RecordVariable(ReplayVariable variable) => throw new System.NotImplementedException();
        /// <summary>
        /// Record a replay event on the current record frame.
        /// </summary>
        /// <param name = "eventID">A unique event ID value used to identify the event type</param>
        /// <param name = "eventData">A replay state containing data associated with the event</param>
        public void RecordEvent(ushort eventID, ReplayState eventData = null) => throw new System.NotImplementedException();
        /// <summary>
        /// Record a method call.
        /// Note that this will also cause the target method to be invoked immediatley.
        /// </summary>
        /// <param name = "method">The delegate method to record</param>
        public void RecordMethodCall(Action method) => throw new System.NotImplementedException();
        /// <summary>
        /// Record a method call.
        /// Note that this will also cause the target method to be invoked immediatley.
        /// </summary>
        /// <typeparam name = "T">The parameter type of the first method parameter</typeparam>
        /// <param name = "method">The delegate method to record</param>
        /// <param name = "arg">The first argument for the target method</param>
        public void RecordMethodCall<T>(Action<T> method, T arg) => throw new System.NotImplementedException();
        /// <summary>
        /// Record a method call.
        /// Note that this will also cause the target method to be invoked immediatley.
        /// </summary>
        /// <typeparam name = "T0">The parameter type of the first method parameter</typeparam>
        /// <typeparam name = "T1">The parameter type of the second method parameter</typeparam>
        /// <param name = "method">The delegate method to record</param>
        /// <param name = "arg0">The first argument for the target method</param>
        /// <param name = "arg1">The second argument for the target method</param>
        public void RecordMethodCall<T0, T1>(Action<T0, T1> method, T0 arg0, T1 arg1) => throw new System.NotImplementedException();
        /// <summary>
        /// Record a method call.
        /// Note that this will also cause the target method to be invoked immediately.
        /// </summary>
        /// <typeparam name = "T0">The parameter type of the first method parameter</typeparam>
        /// <typeparam name = "T1">The parameter type of the second method parameter</typeparam>
        /// <typeparam name = "T2">The parameter type of the third method parameter</typeparam>
        /// <param name = "method">The delegate method to record</param>
        /// <param name = "arg0">The first argument for the target method</param>
        /// <param name = "arg1">The second argument for the target method</param>
        /// <param name = "arg2">The third argument for the target method</param>
        public void RecordMethodCall<T0, T1, T2>(Action<T0, T1, T2> method, T0 arg0, T1 arg1, T2 arg2) => throw new System.NotImplementedException();
        /// <summary>
        /// Record a method call.
        /// Note that this will also cause the target method to be invoked immediately.
        /// </summary>
        /// <typeparam name = "T0">The parameter type of the first method parameter</typeparam>
        /// <typeparam name = "T1">The parameter type of the second method parameter</typeparam>
        /// <typeparam name = "T2">The parameter type of the third method parameter</typeparam>
        /// <typeparam name = "T3">The parameter type of the fourth method parameter</typeparam>
        /// <param name = "method">The delegate method to record</param>
        /// <param name = "arg0">The first argument for the target method</param>
        /// <param name = "arg1">The second argument for the target method</param>
        /// <param name = "arg2">The third argument for the target method</param>
        /// <param name = "arg3">The fourth argument for the target method</param>
        public void RecordMethodCall<T0, T1, T2, T3>(Action<T0, T1, T2, T3> method, T0 arg0, T1 arg1, T2 arg2, T3 arg3) => throw new System.NotImplementedException();
    }
}