/// <summary>
/// This source file was auto-generated by a tool - Any changes may be overwritten!
/// From Unity assembly definition: UltimateReplay.dll
/// From source file: Assets/Ultimate Replay 3.0/Scripts/Runtime/ReplayBehaviour.cs
/// </summary>
using System;
using System.Collections.Generic;
using System.Reflection;
using UnityEngine;
using UltimateReplay.ComponentData;

#if MIRROR
using Mirror;
#endif
#if UNITY_EDITOR
using UnityEditor;
#endif
namespace UltimateReplay
{
    /// <summary>
    /// This interface can be implemented by mono behaviour scripts in order to receive replay start and end events.
    /// It works in a similar way to the 'Start' or 'Update' method however you must explicitly implement the interface as opposed to using magic methods.
    /// This allows for slightly improved performance.
    /// </summary>
    
#if MIRROR && !ULTIMATEREPLAY_DISABLE_MIRROR
    public abstract class ReplayBehaviour : NetworkBehaviour
#else
    public abstract class ReplayBehaviour : MonoBehaviour
#endif
    {
        // Properties 
        /// <summary>
        /// Get the <see cref = "Core.ReplayIdentity"/> associated with this <see cref = "ReplayBehaviour"/>.  
        /// </summary>
        public ReplayIdentity ReplayIdentity
        {
            get => throw new System.NotImplementedException();
            set => throw new System.NotImplementedException();
        }

        /// <summary>
        /// Get the managing <see cref = "ReplayObject"/>.
        /// </summary>
        public ReplayObject ReplayObject
        {
            get => throw new System.NotImplementedException();
        }

        public bool HasPersistentData
        {
            get => throw new System.NotImplementedException();
        }

        public ReplayState ReplayPersistentData
        {
            get => throw new System.NotImplementedException();
        }

        /// <summary>
        /// Get all <see cref = "ReplayVariable"/> associated with this <see cref = "ReplayBehaviour"/>.
        /// </summary>
        public IList<ReplayVariable> Variables
        {
            get => throw new System.NotImplementedException();
        }

        /// <summary>
        /// Returns a value indicating whether this <see cref = "ReplayObject"/> has any <see cref = "ReplayVariable"/>.
        /// </summary>
        public bool HasVariables
        {
            get => throw new System.NotImplementedException();
        }

        /// <summary>
        /// Returns true if the active replay manager is currently recording the scene.
        /// Note: If recording is paused this value will still be true.
        /// </summary>
        public bool IsRecording
        {
            get => throw new System.NotImplementedException();
        }

        public bool IsRecordingPaused
        {
            get => throw new System.NotImplementedException();
        }

        public bool IsRecordingOrPaused
        {
            get => throw new System.NotImplementedException();
        }

        /// <summary>
        /// Returns true if the active replay manager is currently replaying a previous recording.
        /// Note: If playback is paused this value will still be true.
        /// </summary>
        public bool IsReplaying
        {
            get => throw new System.NotImplementedException();
        }

        public bool IsPlaybackPaused
        {
            get => throw new System.NotImplementedException();
        }

        public bool IsReplayingOrPaused
        {
            get => throw new System.NotImplementedException();
        }

        /// <summary>
        /// Get the current playback time in seconds.
        /// This <see cref = "ReplayBehaviour"/> must be attached to an object that is currently being replayed for this value to be valid.
        /// </summary>
        public float PlaybackTime
        {
            get => throw new System.NotImplementedException();
        }

        public float PlaybackTimeNormalized
        {
            get => throw new System.NotImplementedException();
        }

        public float PlaybackTimeScale
        {
            get => throw new System.NotImplementedException();
        }

        /// <summary>
        /// Gets the current <see cref = "PlaybackDirection"/> of replay playback.
        /// </summary>
        public PlaybackDirection PlaybackDirection
        {
            get => throw new System.NotImplementedException();
        }

        // Methods
        /// <summary>
        /// Called by Unity while in editor mode.
        /// Allows the unique id to be generated when the script is attached to an object.
        /// </summary>
        protected virtual void Reset() => throw new System.NotImplementedException();
        /// <summary>
        /// Called by Unity.
        /// </summary>
        protected virtual void Awake() => throw new System.NotImplementedException();
        protected virtual void OnDestroy() => throw new System.NotImplementedException();
        /// <summary>
        /// Called by Unity.
        /// Be sure to call this base method when overriding otherwise replay events will not be received.
        /// </summary>
        protected virtual void OnEnable() => throw new System.NotImplementedException();
        /// <summary>
        /// Called by Unity.
        /// Be sure to call this base method when overriding otherwise replay events will not be received.
        /// </summary>
        protected virtual void OnDisable() => throw new System.NotImplementedException();
        /// <summary>
        /// Called by the replay system when playback is about to start.
        /// You can disable game behaviour that should not run during playback in this method, such as player movement.
        /// </summary>
        protected virtual void OnReplayStart() => throw new System.NotImplementedException();
        /// <summary>
        /// Called by the replay system when playback has ended.
        /// You can re-enable game behaviour in this method to allow the gameplay to 'take over'
        /// </summary>
        protected virtual void OnReplayEnd() => throw new System.NotImplementedException();
        /// <summary>
        /// Called by the replay system when playback is about to be paused or resumed.
        /// </summary>
        /// <param name = "paused">True if playback is about to be paused or false if plyabck is about to be resumed</param>
        protected virtual void OnReplayPlayPause(bool paused) => throw new System.NotImplementedException();
        /// <summary>
        /// Called by the replay system during playback when cached values should be reset to safe default to avoid glitches or inaccuracies in the playback.
        /// </summary>
        protected virtual void OnReplayReset() => throw new System.NotImplementedException();
        /// <summary>
        /// Called by the replay system when non-recordable components should submit data to be recorded to the managing replay object. This method is ideal for recording variables, events, methods calls and similar.
        /// Update can be used instead however 'OnReplayCapture' is guarenteed to be called during the same frame that replay recordable data is serialized.
        /// </summary>
        protected virtual void OnReplayCapture() => throw new System.NotImplementedException();
        /// <summary>
        /// Called by the replay system every frame while playback is active.
        /// </summary>
        /// <param name = "t">A normalized value representing the progress between replay snapshots. Use this value for interpolation or similar smoothing passes</param>
        protected virtual void OnReplayUpdate(float t) => throw new System.NotImplementedException();
        /// <summary>
        /// Called by the replay system when an event has been received during playback.
        /// </summary>
        /// <param name = "replayEvent">The event that was received</param>
        protected virtual void OnReplayEvent(ushort eventID, ReplayState eventData) => throw new System.NotImplementedException();
        /// <summary>
        /// Called by the replay system when the object has been spawned from a prefab instance during playback.
        /// </summary>
        /// <param name = "position"></param>
        /// <param name = "rotation"></param>
        protected virtual void OnReplaySpawned(Vector3 position, Quaternion rotation) => throw new System.NotImplementedException();
        /// <summary>
        /// Force the <see cref = "ReplayIdentity"/> of this component to be regenerated.
        /// </summary>
        public void ForceRegenerateIdentity() => throw new System.NotImplementedException();
        /// <summary>
        /// Record the value of the specified <see cref = "ReplayVariable"/>.
        /// Should only be called when <see cref = "IsRecording"/> is true.
        /// The variable data will be recorded for a single frame. 
        /// To order to record a variable over time, simply call this method every frame.
        /// </summary>
        /// <param name = "variable"></param>
        public void RecordVariable(ReplayVariable variable) => throw new System.NotImplementedException();
        /// <summary>
        /// Record a replay event on the current record frame.
        /// </summary>
        /// <param name = "eventID">A unique event ID value used to identify the event type</param>
        /// <param name = "eventData">A replay state containing data associated with the event</param>
        public void RecordEvent(ushort eventID, ReplayState eventData = null) => throw new System.NotImplementedException();
        /// <summary>
        /// Record a method call.
        /// Note that this will also cause the target method to be invoked immediatley.
        /// </summary>
        /// <param name = "method">The delegate method to record</param>
        public void RecordMethodCall(Action method) => throw new System.NotImplementedException();
        /// <summary>
        /// Record a method call.
        /// Note that this will also cause the target method to be invoked immediatley.
        /// </summary>
        /// <typeparam name = "T">The parameter type of the first method parameter</typeparam>
        /// <param name = "method">The delegate method to record</param>
        /// <param name = "arg">The first argument for the target method</param>
        public void RecordMethodCall<T>(Action<T> method, T arg) => throw new System.NotImplementedException();
        /// <summary>
        /// Record a method call.
        /// Note that this will also cause the target method to be invoked immediatley.
        /// </summary>
        /// <typeparam name = "T0">The parameter type of the first method parameter</typeparam>
        /// <typeparam name = "T1">The parameter type of the second method parameter</typeparam>
        /// <param name = "method">The delegate method to record</param>
        /// <param name = "arg0">The first argument for the target method</param>
        /// <param name = "arg1">The second argument for the target method</param>
        public void RecordMethodCall<T0, T1>(Action<T0, T1> method, T0 arg0, T1 arg1) => throw new System.NotImplementedException();
        /// <summary>
        /// Record a method call.
        /// Note that this will also cause the target method to be invoked immediately.
        /// </summary>
        /// <typeparam name = "T0">The parameter type of the first method parameter</typeparam>
        /// <typeparam name = "T1">The parameter type of the second method parameter</typeparam>
        /// <typeparam name = "T2">The parameter type of the third method parameter</typeparam>
        /// <param name = "method">The delegate method to record</param>
        /// <param name = "arg0">The first argument for the target method</param>
        /// <param name = "arg1">The second argument for the target method</param>
        /// <param name = "arg2">The third argument for the target method</param>
        public void RecordMethodCall<T0, T1, T2>(Action<T0, T1, T2> method, T0 arg0, T1 arg1, T2 arg2) => throw new System.NotImplementedException();
        /// <summary>
        /// Record a method call.
        /// Note that this will also cause the target method to be invoked immediately.
        /// </summary>
        /// <typeparam name = "T0">The parameter type of the first method parameter</typeparam>
        /// <typeparam name = "T1">The parameter type of the second method parameter</typeparam>
        /// <typeparam name = "T2">The parameter type of the third method parameter</typeparam>
        /// <typeparam name = "T3">The parameter type of the fourth method parameter</typeparam>
        /// <param name = "method">The delegate method to record</param>
        /// <param name = "arg0">The first argument for the target method</param>
        /// <param name = "arg1">The second argument for the target method</param>
        /// <param name = "arg2">The third argument for the target method</param>
        /// <param name = "arg3">The fourth argument for the target method</param>
        public void RecordMethodCall<T0, T1, T2, T3>(Action<T0, T1, T2, T3> method, T0 arg0, T1 arg1, T2 arg2, T3 arg3) => throw new System.NotImplementedException();
    }
}