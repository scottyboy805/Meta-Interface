/// <summary>
/// This source file was auto-generated by a tool - Any changes may be overwritten!
/// From Unity assembly definition: UltimateReplay.dll
/// From source file: Assets/Ultimate Replay 3.0/Scripts/Runtime/ReplayComponents/Formatters/ReplayAnimatorFormatter.cs
/// </summary>
using System;
using UnityEngine;

namespace UltimateReplay.Formatters
{
    public sealed class ReplayAnimatorFormatter : ReplayFormatter
    {
        // Types
        /// <summary>
        /// Serialize flags used to indicate which data elements are stored.
        /// </summary>
        [Flags]
        public enum ReplayAnimatorSerializeFlags : byte
        {
            /// <summary>
            /// The main state layer data will be serialized.
            /// </summary>
            MainState = 1 << 1,
            /// <summary>
            /// Sub state layers will be serialized.
            /// </summary>
            SubStates = 1 << 2,
            /// <summary>
            /// Parameter values will be serialized.
            /// </summary>
            Parameters = 1 << 3,
            IKPosition = 1 << 4,
            IKRotation = 1 << 5,
            IKWeights = 1 << 6,
            /// <summary>
            /// Supported data elements will be serialized using low precision mode.
            /// </summary>
            LowPrecision = 1 << 7,
        }

        /// <summary>
        /// Contains data about a specific animator state.
        /// </summary>
        public struct ReplayAnimatorState
        {
            // Public
            /// <summary>
            /// The hash of the current animator state.
            /// </summary>
            public int stateHash;
            /// <summary>
            /// The normalized playback time of the current animation.
            /// </summary>
            public float normalizedTime;
            /// <summary>
            /// The current speed of the animation.
            /// </summary>
            public float speed;
            /// <summary>
            /// The current speed multiplier value.
            /// </summary>
            public float speedMultiplier;
        }

        /// <summary>
        /// Contains data about a specific animator parameter.
        /// </summary>
        public struct ReplayAnimatorParameter
        {
            // Public
            /// <summary>
            /// The name hash of the parameter.
            /// </summary>
            public int nameHash;
            /// <summary>
            /// The <see cref = "AnimatorControllerParameterType"/> which describes the type of parameter.
            /// </summary>
            public AnimatorControllerParameterType parameterType;
            /// <summary>
            /// The integer value of the parameter.
            /// </summary>
            public int intValue;
            /// <summary>
            /// The float value of the parameter.
            /// </summary>
            public float floatValue;
            /// <summary>
            /// The bool value of the parameter.
            /// </summary>
            public bool boolValue;
        }

        /// <summary>
        /// Contains data about a specific animator IK limb.
        /// </summary>
        public struct ReplayAnimatorIKTarget
        {
            // Public
            /// <summary>
            /// The target position for the IK limb.
            /// </summary>
            public Vector3 targetPosition;
            /// <summary>
            /// The target rotation for the IK limb.
            /// </summary>
            public Quaternion targetRotation;
            /// <summary>
            /// The position weight for the IK limb.
            /// </summary>
            public float positionWeight;
            /// <summary>
            /// The rotation weight for the IK limb.
            /// </summary>
            public float rotationWeight;
        }

        // Public
        public const int IKLimbCount = 4;
        public bool ReplayParameters
        {
            get
            {
                return (serializeFlags & ReplayAnimatorSerializeFlags.Parameters) != 0;
            }

            set
            {
                // Clear bit
                serializeFlags &= ~ReplayAnimatorSerializeFlags.Parameters;
                // Set bit
                if (value == true)
                    serializeFlags |= ReplayAnimatorSerializeFlags.Parameters;
            }
        }

        public bool LowPrecision
        {
            get
            {
                return (serializeFlags & ReplayAnimatorSerializeFlags.LowPrecision) != 0;
            }

            set
            {
                // Clear bit
                serializeFlags &= ~ReplayAnimatorSerializeFlags.LowPrecision;
                // Set bit
                if (value == true)
                    serializeFlags |= ReplayAnimatorSerializeFlags.LowPrecision;
            }
        }

        /// <summary>
        /// Get the <see cref = "ReplayAnimatorState"/> information for the main state.
        /// </summary>
        public ReplayAnimatorState MainState
        {
            get
            {
                if (states.Length == 0)
                    return new ReplayAnimatorState();
                return states[0];
            }

            set
            {
                if (states.Length == 0)
                    states = new ReplayAnimatorState[1];
                states[0] = value;
            }
        }

        /// <summary>
        /// Get all <see cref = "ReplayAnimatorState"/> information for all sub states.
        /// </summary>
        public ReplayAnimatorState[] States
        {
            get
            {
                return states;
            }

            set
            {
                states = value;
                if (states == null)
                    states = new ReplayAnimatorState[0];
            }
        }

        /// <summary>
        /// Get all <see cref = "ReplayAnimatorParameter"/> that will be serialized.
        /// </summary>
        public ReplayAnimatorParameter[] Parameters
        {
            get
            {
                return parameters;
            }

            set
            {
                parameters = value;
                if (parameters == null)
                    parameters = new ReplayAnimatorParameter[0];
            }
        }

        /// <summary>
        /// Get all <see cref = "ReplayAnimatorIKTarget"/> that will be serialized.
        /// </summary>
        public ReplayAnimatorIKTarget[] IKTargets
        {
            get
            {
                return ikTargets;
            }

            set
            {
                ikTargets = value;
                if (ikTargets == null || ikTargets.Length != IKLimbCount)
                    ikTargets = new ReplayAnimatorIKTarget[IKLimbCount];
            }
        }

        // Constructor
        public ReplayAnimatorFormatter()
        {
            for (int i = 0; i < ikTargets.Length; i++)
            {
                // Set to identity to avoid scalar assertion
                ikTargets[i].targetRotation = Quaternion.identity;
            }
        }

        // Methods
        /// <summary>
        /// Invoke this method to serialize the animator data to the specified <see cref = "ReplayState"/>.
        /// </summary>
        /// <param name = "state">The state object used to store the data</param>
        public override void OnReplaySerialize(ReplayState state) => throw new System.NotImplementedException();
        /// <summary>
        /// Invoke this method to deserialize the animator data from the specified <see cref = "ReplayState"/>.
        /// </summary>
        /// <param name = "state">The state object which should contain valid animator data</param>
        public override void OnReplayDeserialize(ReplayState state) => throw new System.NotImplementedException();
        public ReplayAnimatorIKTarget GetIKTargetInfo(AvatarIKGoal goal) => throw new System.NotImplementedException();
        public void SetIKTargetInfo(AvatarIKGoal goal, in ReplayAnimatorIKTarget target) => throw new System.NotImplementedException();
    }
}