/// <summary>
/// This source file was auto-generated by a tool - Any changes may be overwritten!
/// From Unity assembly definition: DLCToolkit.dll
/// From source file: Assets/Ultimate DLC Toolkit/Scripts/Runtime/Toolkit/DLCContent.cs
/// </summary>
using DLCToolkit.Assets;
using DLCToolkit.DRM;
using DLCToolkit.Format;
using System;
using System.Collections;
using System.Collections.Generic;
using System.IO;
using UnityEngine;
using UnityEngine.Events;

namespace DLCToolkit
{
    /// <summary>
    /// Represents a DLC loaded in memory.
    /// Provides access to metadata, icons, plus API's for loading assets and scenes.
    /// Will remain in memory until <see cref = "Unload(bool)"/>, <see cref = "Dispose"/> or until the game exits.
    /// </summary>
    public sealed class DLCContent : MonoBehaviour, IDLCAsyncProvider, IDisposable
    {
        // Events
        /// <summary>
        /// Called when the DLC content is just about to be unloaded.
        /// Usually this means an unload request was made of the content was disposed.
        /// </summary>
        [HideInInspector]
        public UnityEvent OnWillUnload;
        /// <summary>
        /// Called when the DLC content has finished unloading.
        /// Usually this means an unload request was made of the content was disposed.
        /// </summary>
        [HideInInspector]
        public UnityEvent OnUnloaded;
        /// <summary>
        /// Check if the DLC content has been successfully loaded.
        /// </summary>
        public bool IsLoaded
        {
            get => throw new System.NotImplementedException();
        }

        /// <summary>
        /// Check if the DLC content is currently loading.
        /// </summary>        
        public bool IsLoading
        {
            get => throw new System.NotImplementedException();
        }

        /// <summary>
        /// Get the local path where the DLC content was loaded from.
        /// </summary>
        /// <exception cref = "DLCNotLoadedException">The DLC is not currently loaded</exception>
        public string HintLoadPath
        {
            get => throw new System.NotImplementedException();
        }

        /// <summary>
        /// Get the <see cref = "IDLCNameInfo"/> for the loaded DLC content.
        /// Provides access to useful identifying data such as name, version and unique key.
        /// </summary>
        /// <exception cref = "DLCNotLoadedException">The DLC is not currently loaded</exception>
        public IDLCNameInfo NameInfo
        {
            get => throw new System.NotImplementedException();
        }

        /// <summary>
        /// Get the <see cref = "IDLCMetadata"/> for the loaded DLC content.
        /// Provides access to useful metadata such as name, version, author information and more.
        /// </summary>
        /// <exception cref = "DLCNotLoadedException">The DLC is not currently loaded</exception>
        public IDLCMetadata Metadata
        {
            get => throw new System.NotImplementedException();
        }

        /// <summary>
        /// Get the <see cref = "IDLCIconProvider"/> for the loaded DLC content.
        /// Provides access to all icons associated with the DLC if available.
        /// </summary>
        /// <exception cref = "DLCNotLoadedException">The DLC is not currently loaded</exception>
        public IDLCIconProvider IconProvider
        {
            get => throw new System.NotImplementedException();
        }

        /// <summary>
        /// Get a collection <see cref = "DLCSharedAsset"/> for the loaded DLC content listing each asset that was included.
        /// Shared assets are all non-scene assets types such as prefab, texture, material, audio clip, etc.
        /// Provides access to useful asset metadata such as name, path, extension, type and more.
        /// </summary>
        /// <exception cref = "DLCNotLoadedException">The DLC is not currently loaded or is loaded in metadata only mode</exception>
        public DLCAssetCollection<DLCSharedAsset> SharedAssets
        {
            get => throw new System.NotImplementedException();
        }

        /// <summary>
        /// Get a collection <see cref = "DLCSceneAsset"/> for the loaded DLC content listing each scene asset that was included.
        /// Scene assets are simply Unity scenes.
        /// Provides access to useful asset metadata such as name, path, extension, type and more.
        /// </summary>
        /// <exception cref = "DLCNotLoadedException">The DLC is not currently loaded or is loaded in metadata only mode</exception>
        public DLCAssetCollection<DLCSceneAsset> SceneAssets
        {
            get => throw new System.NotImplementedException();
        }

        /// <summary>
        /// Request that the DLC contents be unloaded from memory.
        /// This will case DLC metadata, assets and scenes to be unloaded.
        /// Note that the <see cref = "DLCContent"/> container object will not be destroyed and will remain in memory until manually destroyed.
        /// Use <see cref = "Dispose"/> to unload the content and to recycle the <see cref = "DLCContent"/> container object for use in other DLC load operations.
        /// </summary>
        /// <param name = "withAssets">Should asset instances also be unloaded</param>
        public void Unload(bool withAssets = true) => throw new System.NotImplementedException();
        public DLCAsync UnloadAsync(bool withAssets = true) => throw new System.NotImplementedException();
        /// <summary>
        /// Unload this DLC and release all associated resources.
        /// Will call <see cref = "Unload(bool)"/> with `true` argument internally to cause the DLC to be unloaded from memory.
        /// Note that this will cause the <see cref = "DLCContent"/> container object to be recycled and will become available for other load operations.
        /// For that reason references should not be kept after dispose has been called.
        /// </summary>
        public void Dispose() => throw new System.NotImplementedException();
        Coroutine IDLCAsyncProvider.RunAsync(IEnumerator routine) => throw new System.NotImplementedException();
    }
}